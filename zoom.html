<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Gallery</title>
  <style>
    * {
      box-sizing: border-box;
      touch-action: none;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      height: 100vh;
      overflow: hidden;
    }
    .viewer {
      display: flex;
      width: 200vw;
      height: 100vh;
      transition: transform 0.3s ease;
    }
    .image-wrapper {
      width: 100vw;
      height: 100vh;
      flex-shrink: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .image-wrapper img {
      max-width: 100%;
      max-height: 100%;
    }

    .zoom-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .zoom-overlay img {
      position: absolute;
      max-width: 100%;
      max-height: 100%;
      transform-origin: center center;
      will-change: transform;
      transition: transform 0.05s ease;
    }
  </style>
</head>
<body>

  <div class="viewer" id="viewer">
    <div class="image-wrapper">
      <img src="https://stimg.cardekho.com/images/carexteriorimages/930x620/Audi/Q5-2026/11947/1741688731850/front-left-side-47.jpg" />
    </div>
    <div class="image-wrapper">
      <img src="https://stimg.cardekho.com/images/carexteriorimages/930x620/Audi/Q5-2026/11947/1741688607915/side-view-(left)-90.jpg" />
    </div>
  </div>

  <div class="zoom-overlay" id="zoomOverlay">
    <img id="zoomImg" />
  </div>

  <script>
    const viewer = document.getElementById("viewer");
    const wrappers = viewer.querySelectorAll(".image-wrapper");
    const images = viewer.querySelectorAll(".image-wrapper img");
    const zoomOverlay = document.getElementById("zoomOverlay");
    const zoomImg = document.getElementById("zoomImg");

    let currentIndex = 0;
    let startX = 0, startY = 0, deltaX = 0;
    let isSwiping = false;
    let scale = 1, lastScale = 1, panX = 0, panY = 0;
    let originX = 0, originY = 0;
    let pinchStartDist = 0;
    let isPinching = false;
    let lastTap = 0;
    let lastTouchTime = 0;

    function showImage(index) {
      currentIndex = Math.max(0, Math.min(index, wrappers.length - 1));
      viewer.style.transform = `translateX(-${currentIndex * 100}vw)`;
    }

    // Double-tap to zoom overlay
    images.forEach((img) => {
      img.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTouchTime < 300) {
          zoomImg.src = img.src;
          zoomOverlay.style.display = 'flex';
          zoomImg.style.transform = 'scale(1) translate(0px, 0px)';
          zoomImg.style.transformOrigin = 'center center';
          scale = 1;
          panX = panY = 0;
          lastScale = 1;
        }
        lastTouchTime = now;
      });
    });

    viewer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        isSwiping = true;
      }
    });

    viewer.addEventListener('touchmove', (e) => {
      if (isSwiping && e.touches.length === 1) {
        deltaX = e.touches[0].clientX - startX;
        viewer.style.transform = `translateX(calc(${-currentIndex * 100}vw + ${deltaX}px))`;
      }
    });

    viewer.addEventListener('touchend', () => {
      if (Math.abs(deltaX) > 50) {
        showImage(currentIndex + (deltaX < 0 ? 1 : -1));
      } else {
        showImage(currentIndex);
      }
      deltaX = 0;
      isSwiping = false;
    });

    zoomOverlay.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        isPinching = true;
        pinchStartDist = getDistance(e.touches);

        // Set transform origin from pinch center
        const x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const bounds = zoomImg.getBoundingClientRect();
        const offsetX = ((x - bounds.left) / bounds.width) * 100;
        const offsetY = ((y - bounds.top) / bounds.height) * 100;
        originX = offsetX;
        originY = offsetY;
        zoomImg.style.transformOrigin = `${originX}% ${originY}%`;
      } else if (e.touches.length === 1 && scale > 1) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      }
    });

    zoomOverlay.addEventListener('touchmove', (e) => {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault();
        const dist = getDistance(e.touches);
        scale = Math.max(1, Math.min(4, lastScale * (dist / pinchStartDist)));
        applyTransform();
      } else if (scale > 1 && e.touches.length === 1) {
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        panX += dx;
        panY += dy;
        clampPan();
        applyTransform();
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      }
    });

    zoomOverlay.addEventListener('touchend', (e) => {
      if (isPinching) {
        lastScale = scale;
        isPinching = false;
      } else if (e.touches.length === 0) {
        const now = Date.now();
        if (now - lastTap < 300) {
          zoomOverlay.style.display = 'none';
          scale = 1;
          lastScale = 1;
        }
        lastTap = now;
      }
    });

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function applyTransform() {
      zoomImg.style.transform = `scale(${scale}) translate(${panX}px, ${panY}px)`;
    }

    function clampPan() {
      const bounds = zoomImg.getBoundingClientRect();
      const w = bounds.width;
      const h = bounds.height;

      const maxPanX = Math.max(0, (w - window.innerWidth) / 2);
      const maxPanY = Math.max(0, (h - window.innerHeight) / 2);

      panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
      panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
    }

    showImage(0);
  </script>

</body>
</html>
